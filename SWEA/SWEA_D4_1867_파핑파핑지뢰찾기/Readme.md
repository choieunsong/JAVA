# 문제 정의

1. N*N (1≤N≤300)인 맵에 지뢰와 빈칸이 있다. 
2. 지뢰가 아닌 빈칸을 눌렀을 때 8방향에 지뢰가 하나도 없다면 0으로 출력하고 8방향 칸에 지뢰가 몇개 있는지 표시한다. 8방향 칸 중 0이 있으면 그 칸도 연속적으로 8방향 칸에 숫자가 표시된다.
3. 빈칸을 클릭해서 모든 칸에 숫자가 나타나게 할 때 클릭하는 최소횟수를 출력하라

# 문제 풀이

## 아이디어1

1. 먼저 8방향에 지뢰가 하나도 없는 칸들을 전부 구해서 arraylist에 좌표를 저장한다.
2. 그 좌표들을 부분집합으로 선택해서 지뢰찾기를 할 때 회수가 최소가 되는 값을 구한다.
- 시간제한. N = 300일때 90,000이 되기 때문에 부분집합 불가능

## 아이디어2

1. dfs로 풀기. 0좌표 미리 전부 구해준다. pq에 좌표들과 칠한 칸을 넣어준다. 
2. 그 좌표들로 하나씩 시도해가면서 최소값 찾기 
- 문제 똑바로 안읽네

## 아이디어3

1. 정답을 표시하는 int ans[N][N] 배열을 하나 더 만들어서 '*' 지뢰를 기준으로 8방 탐색해 칸에 숫자를 기록한다.
2. 맵을 탐색해서 ans 수가 0인 칸을 만나면 cnt를 1 증가하고 bfs로 8방탐색을 진행한다. 주변 칸 중 아직 방문하지 않았고, 지뢰가 아닌 칸들은 방문 체크를 해준다. 만약 0인 칸이 또 있으면 큐에 넣어준다.
3. 이런식으로 0인 칸을 기준으로 연쇄적으로 폭발할 때 최소 클릭 횟수를 구해준다.
4. 그 다음 칸이 0이 아니고 연쇄적으로 폭발하지 않은 수들을 구하기 위해, 아직 방문하지 않았고 지뢰가 아닌 칸들을 찾아 cnt를 1씩 증가해 준다.

# 정리

문제를 또 똑바로 안봐서 3번 뒤엎고 겨우 풀었다. 지뢰를 기준으로 8방탐색을 해 미리 칸들의 수를 체크해 준 아이디어가 똑똑했다.