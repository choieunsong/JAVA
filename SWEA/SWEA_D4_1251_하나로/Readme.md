# MST

Prim: 정점 중심(인접행렬, 인접 리스트)

Kruskal: 간선 중심 - 간선 리스트

# 문제 정의

1. 섬의 개수 N(1≤N≤1000), 각 섬들의 좌표와 환경 세율이 주어질 때 모든 섬들을 연결하는 다리의 최소 비용을 구하라

# 문제 풀이 - Prim

1. 밀집그래프일때 인접 리스트로 풀면 좋다. 이 문제에선 섬의 개수만 주어지고 간선의 수가 주어지지 않기 때문에 프림으로 푸는 게 좋다.
2. Prim
    1. long adjMatrix[][]를 만들어서 각 섬들별로 모든 거리를 저장해 준다.
    2. 각 섬들 기준 다른 섬들과 간선의 최소값을 저장할 long[] minEdge를 만들고 최대값을 넣어준다.
    3. MST에 포함되어 있는지 여부를 체크해주는 boolean[] visited를 만든다.
    4. 섬 0부터 시작하므로 minEdge[0] = 0
    5. minEdge를 탐색하며 아직 방문하지 않았고 간선 비용이 최소인 섬을 찾는다. 
    6. 선택한 섬은 MST에 포함되니 visited[minNo] = true해주고 간선 값을 결과에 더해준다.
    7. 현재 섬을 기준으로 adjMatrix[섬][i] 중 아직 방문하지 않았고 minEdge[i]보다 값이 작은 애들을 minEdge에 넣어준다. ⇒ 원래 간선보다 현재 선택한 섬을 거쳐서 방문하는게 더 빠른 경우
    8. 뽑은 수가 N이 되면 MST가 전부 만들어졌다는 뜻이니 종료
3. 시간 복잡도: 탐색할 섬 구하고 간선 업데이트 하는데 O(2v) x  전체 정점에 대한 반복 O(v) = O(v^2)

# 문제 풀이 - Prim PQ

1. 시간 복잡도: 최소 정점 추출 O(VlogV) + 최소 간선 비용 업데이트마다 PQ에 넣기 O(ElogV)

    ⇒ 여기선 간선이 V^2이므로 T = O(V^2 logV)

    ⇒ pq를 안썼을때보다 살짝 느리다.

2. class Vertex를 만들어서 거기에 인덱스, 간선 비용 저장, compareTo 구현
3. Prim
    1. pq에 vertex(0,0)을 넣어서 탐색 시작 
    2. pq.poll하면 가장 간선 비용이 작은 애가 나옴. 방문처리 하고 결과값에 cost 더해줌
    3. 현재 섬을 기준으로 adjMatrix[섬][i] 중 아직 방문하지 않았고 minEdge[i]보다 값이 작은 애들을 minEdge에 넣어준다. ⇒ 원래 간선보다 현재 선택한 섬을 거쳐서 방문하는게 더 빠른 경우
    4. 뽑은 수가 N이 되면 MST가 전부 만들어졌다는 뜻이니 종료

# 정리

프림 어렵다..크루스칼이 더 쉽다ㅠㅠ