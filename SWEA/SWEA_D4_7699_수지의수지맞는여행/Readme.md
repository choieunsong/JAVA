# 문제 정의

1. 수지가 R*C 맵을 탐방하면서 알파벳을 각자 한번만 마주치며 여행하려 한다.
2. 수지가 여행하면서 볼 수 있는 명물의 최대 개수를 출력하라
3. 1≤R,C≤20

# 문제 풀이

1. 알파벳 a~z까지 방문했는지 체크하는 boolean alpha[26] 배열을 만든다
2. 수지가 (0,0)부터 시작하니 dfs 탐색 전에 첫 위치의 알파벳을 방문 처리 한다.
3. dfs로 r, c, cnt를 인자로 넘긴다. dfs 첫줄에 현재 cnt(알파벳 개수)와 max를 비교 갱신한다.
4. 현재 r,c에서 사방탐색하면서 아직 방문되지 않은 알파벳이면 방문처리하고 dfs를 다시 호출한다. dfs 호출 후 다시 방문해제해야 한다.

# 정리

전에 백준에서 알파벳이라는 똑같은 문제를 풀었었는데 잊어버리고 있었다. 처음에 bfs로 비트로 flag 만들어서 풀어야겠다 생각했었는데 방문처리가 너무 까다로워지기 때문에 dfs가 더 깔끔하다. 너무 한 아이디어에 매물되지 말자!

char: 2바이트, int: 4바이트. char가 더 빠를것 같지만 mips의 기본단위가 4byte이기 때문에 int가 더 빠르다.