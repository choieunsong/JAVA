# 문제 정의

1. 크기가 N인 수열이 있을 때 원소 Ai의 오른쪽에 있으면서 Ai보다 큰 수 중에 가장 왼쪽에 있는 수를 출력하라.
2. 1 ≤ N ≤ 1,000,000, 1 ≤ A ≤ 1,000,000

# 문제 풀이

1. arr[N]: 수열을 입력받을 배열, result[N]: 오큰수를 저장할 배열
2. 수열의 끝에부터 오큰수를 stack에 저장하며 탐색한다.
3. Stack에 arr[N-1]을 push하고 result[N-1] = -1 저장
4. N-2부터 0까지 반복문으로 탐색
    1. stack.peek이 원소보다 크면 오큰수이므로 result에 저장
    2. 원소가 stack.peek보다 크거나 같으면 오큰수를 만날때까지 stack을 pop
    3. 만약 stack이 비었으면 오큰수가 없으므로 result에 -1을 저장
    4. 아니면 stack.peek을 result에 저장
    5. 현재 원소를 다음 탐색을 위해 stack에 push한다.
5. 주의! N이 백만이므로 reult를 출력할 때 stringbuilder로 출력

# 정리

정올의 불행한 날과 비슷한 문제였다. 전에 라인 문제 중에 오큰수와 비슷한 문제가 있어서 문제를 추가한건데 라인보다 훨씬 쉬웠던 것 같다..그리고 처음에 반복문을 돌면서 결과를 출력했더니 시간초과가 떠서 stringBuidler를 쓰니까 통과됐다. N이 커질 때는 무조건 StringBuilder로 출력하자