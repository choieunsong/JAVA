# 문제정의

1. 민식이가 0, 도착지가 1일 때 1에 도착할때까지 걸리는 최소 이동 횟수를 출력하라. 만약 미로를 탈출할 수 없으면 -1을 출력하라 
2. 문이 A~F까지 있고 각 문은 해당하는 키 a~f까지 가지고 있을 때 이동 하능하다. 

# 문제 풀이

1. bfs 방문체크에서 보유한 키의 상태를 일일이 구분해야 하기 때문에 visit[R][C]1<<7]로 선언해야 한다. 키는 알파벳 소문자 a~f 까지니 0~6까지 비트를 abcdef로 대응하고 0이면 해당 위치의 키가 없는 것, 1이면 있는 것으로 표현한다.
2. 큐에 { r: r위치, c: c위치, flag: 보유한 키 상태} 현재 민식이 위치와 아무 키를 보유하고 있지 않으니 flag = 0을  입력하고 방문체크 한다.
3. 큐에서 원소를 빼내서 사방탐색을 하는데 경계 밖이거나, 이미 해당 좌표에 현재 키상태로 방문했거나, 칸이 벽이면(#) continue한다.
4. 다음 이동할 칸이 A~F면 a~f를 가지고 있는지 비트마스크로 체크한다. `(flag & (1 << key)) == 0`
5. 다음 이동할 칸이 a~f면 flag에 해당 알파벳에 대응하는 위치에 1을 표시한다.  `nflag = flag | (1 << (map[nr][nc] - 'a'));`

# 정리

또 문제 잘못보고 키가 알파벳 전체인줄 알고 visit 배열을 1<<26으로 했다가 메모리 초과 떴다. 아이패드로 정리 안했다고 이렇게 실수가 자잘자잘하게 많아질 줄이야. 비트마스크에 점점 익숙해지는 것 같아서 신난다!