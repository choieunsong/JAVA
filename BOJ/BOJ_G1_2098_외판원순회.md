# 문제 정의

1. 도시의 수(2≤N≤16)이 주어지고 각 도시로 가기 위한 비용이 주어질 때 외판원이 중복하지 않게 모든 도시를 거쳐 다시 원래대로 돌아올 때 최소비용을 출력하시오


# 문제 풀이
1. N이 16까지기 때문에 일반 순열로 풀 수 없는 문제다. 재귀 + memoization으로 풀어야 한다.
2. dp[N][1<<N]을 만들어서 각 도시에서 방문한 도시 상태의 값을 저장해준다. 
3. 현재 어떤 도시를 방문했는지 상태를 비트 flag로 표시. flag가 1111이면 모든 도시를 방문
4. for문으로 아직 방문하지 않고 연결된 도시를 골라서 도시 인덱스, flag를 인자로 재귀함수를 호출해준다.
5. 현재까지 방문한 도시의 비용(dp[cur][flag])와 연결된 도시로 가는 비용 + 다음 도시에서 리턴한 비용을 비교해서 작은 값을 dp[cur][flag]에 저장한다. (그러기 위해 미리 dp[cur][flag] = INF).
6. 기저조건으로 flag가 1111이면 모든 도시 순회한 것이니 리턴
    1. 만약 마지막 도시에서 첫 도시로 갈 수 없으면 INF 값 리턴
    2. 만약 갈 수 있으면 map[cur][0] 리턴
7. 기저조건으로 dp[cur][flag]가 존재하면 그 값을 리턴(memoization)


# 정리
dp는 정말 쥐약이다..너무 어렵다ㅠㅠdp의 첫 열을 각 도시로 정하긴 했지만 두번째 열을 상태로 저장하는 건 생각하지 못했다. 그리고 모든 도시에 대해 TSP를 구하지 않아도 된다. 2→0→1→3→2 와 0→1→3→2→0은 같은 값이기 때문에 0에 대해서만 TSP를 구해줘도 된다.