# 문제 정의

1. 보석이 총 N개, 배낭의 수가 K개가 있다. (1≤N,K≤300,000)
2. 각 보석은 무게 M과 가격 C를 가지고 있으며 각 가방엔 한개의 보석만 넣을 수 있고 각 가방엔 담을 수 있는 최대 무게가 주어진다.
3. 훔칠 수 있는 보석 가격 합의 최댓값을 출력하시오

# 문제 풀이

## 아이디어 1

1. 가방 무게를 오름차순으로 정렬한다. 
2. 현재 가방에서 담을 수 있는 보석의 최대 가격을 찾는다.
3. 현재 가방에서 가능한 최대 무게를 result에 더해준다.
4. 보석을 중복해서 담으면 안되기 때문에 선택한 보석 가격은 0으로 업데이트 한다.
5. 가방 끝까지 2~4 반복
- 시간초과. N,K가 300,000이므로 이중 반복 시 시간복잡도 90억

## 아이디어 2

1. 가방 무게를 오름차순으로 정렬. 보석도 무게순으로 정렬한다.
2. PrioirtyQueue에 가방 무게를 넘지 않는 보석들 가격을  전부 저장한다.
3. PriorityQueue는 보석 가격을 내림차순으로 정렬한다. pq에는 가방 무게를 넘지 않으면서 가장 가격이 높은 보석이 peek에 있다.
4. peek을 poll하고 가격을 sum에 더해준다.
5. 주의! 배낭엔 보석이 있어도 없어도 되기 때문에 만약 pq에 보석이 없으면 sum을 해주면 안된다.

# 정리

도저히 안풀려서 블로그를 참고해서 풀었다. 2번 아이디어와 비슷하게 생각하면서 저걸 lowerBound, upperBound를 써야하나 하며 실마리가 안잡혀서 끙끙거렸는데 priorityQueue를 보고 아~ 하고 머릿속이 밝아졌다. 아직 머릿속의 로직을 끄집어내서 적절하게 구현하는 실력이 부족한 것 같다. 자료구조를 잘 활용할 수 있게 더 정진하자.