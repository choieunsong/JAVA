# 문제 풀이

1. 3x3 배열 A에서 1초가 지날때마다 배열에 연산이 적용됨
2. R연산: 행개수 ≥ 열개수, 배열 A의 모든 행에 대해 연산 적용
3. C연산: 행개수 < 열개수, 배열 A의 모든 열에 대해 연산 적용
4. 한 행, 열에 있어서 각각의 수가 몇 번 나왔는지 세서, 수의 등장 횟수를 오름차순으로 (수, 횟수) 넣음. [3,1,1]이면 [3,1,1,2]
5. 행 또는 열의 크기가 달라졌을 때 가장 큰 행/열을 기준으로 0으로 채움
6. A[r][c] = k가 되는 최소 시간을 구하시오. 만약 100초 후에도 k가 안되면 -1 출력
7. 1 ≤ r,c,k ≤ 100

# 문제 풀이

1. A[r][c] = k이면 연산 할 필요 없이 0을 출력하면 된다.
2. i=1부터 100까지 반복하면서 R≥C이면 R연산을, 아니면 C연산을 수행한다. 예를 들어서 R연산의 단계를 생각해보자.
    1. A의 모든 행에 대해 int[] num에 숫자가 몇 번 나오는지 체크한다. 동시에 A칸은 0으로 비워줘야 한다.
    2. PriorityQueue에 num의 값을 {수, 횟수} 배열로 저장한다. pq는 횟수가 작은 순서대로, 같으면 수가 작은 순서로 정렬하게 Comparator를 설정한다.
    3. pq가 빌때까지 A의 행을 채워넣는다. A[r][idx++] = x[0], A[r][idx++] = x[1]
    4. idx로 C의 최댓값을 구해야 하므로 idx-1과 C를 비교 갱신한다.
3. C연산도 R연산과 마찬가지로 수행한다.
4. R연산 혹은 C연산이 끝난 후 A[r][c] = k이면 반복문을 종료하고 시간을 return

# 정리

어려운 문제는 아닌데 지저분한 문제였다. 근데 한번에 통과돼서 좀 당황스러웠다. 시간제한이 0.5초라서 이게 되나? 싶었는데 메모리가 512메가인걸 보고 납득함ㅋㅋㅋ100x100 배열이므로 연산이 5000만번 이내고 PriorityQueue를 사용하니까 됐다.