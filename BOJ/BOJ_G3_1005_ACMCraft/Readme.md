# 문제 정의

1. 매 게임마다 건물을 짓는 순서가 있고 건설하는데 delay가 존재한다.
2. 1 → 2, 1→ 3, 2→ 4, 3 → 4이면 4번 건물을 짓기 위해 2, 3번 건물이 전부 건설될때까지 기다려야한다.
3. 건물 W를 건설완료하는 데 걸리는 최소시간을 출력하라

# 위상정렬

[https://gmlwjd9405.github.io/2018/08/27/algorithm-topological-sort.html](https://gmlwjd9405.github.io/2018/08/27/algorithm-topological-sort.html)

[https://m.blog.naver.com/ndb796/221236874984](https://m.blog.naver.com/ndb796/221236874984)

어떤 일을 하는 순서를 찾는 알고리즘

1. 진입 차수가 0인 정점(들어오는 간선의 수가 0)을 선택
    1. 초기에 간선의 수가 0인 모든 정점을 큐에 삽입
2. 큐에서 원소를 꺼내 연결된 모든 간선(진출간선) 제거
3. 간선 제거 이후 진입차수가 0이 된 정점을 큐에 삽입

# 문제 풀이

{1→3}, {2→3} 순서로 건물을 지을 수 있고 W가 3이다. 1{10), 2(30), 3(20)이면 1과 2가 종료되는  시간(30) + 3 건설하는 시간(20) = 50이 된다. 각 건물별로 건설하는데 소요되는 최대 시간을 배열에 저장하는 것이 키포인트다. 

1. inDegree[N+1] 배열에 각 정점의 진입차수를 기록한다. 
2. 처음 진입차수가 0인 원소를 큐에 넣는다. 
3. 큐에서 꺼낸 원소에 연결된 간선을 탐색하고, 다음 건물을 짓기 전에 필요한 시간을 기록해준다. pre[N+1] 배열을 만들어서 `Math.max(pre[next], pre[cur] + cost[cur])`로 next 건물을 짓기 위해 cost가 가장 큰 값을 저장. 다음 건물의 진입 차수를 1씩 감소하고 진입차수가 0인 건물은 다시 큐에 넣어준다.
4. 큐가 빌때까지 3을 반복하면 모든 정점에 대해 건물을 짓기 전 cost가 저장된다. result는 `pre[W] + cost[W]`가 된다.

# 정리

위상정렬을 처음 공부했는데 로직 자체는 간단해서 엄청 어렵진 않았다. 순서가 정해져 있는 작업을 수행해야 할 때 알맞은 알고리즘이라 이곳저곳에 유용하게 사용할 수 있을 것 같다. 더 익숙해지면..