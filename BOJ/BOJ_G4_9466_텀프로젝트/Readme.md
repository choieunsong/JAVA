# 문제 정의

1. 각 학생마다 텀 프로젝트를 같이 하고 싶은 팀원 숫자를 갖고 있다.
2. s1 → s2, s2 → s3 ... sn → s1이면 한 팀이 된다. 어느 프로젝트 팀에도 속하지 않은 학생들의 수를 출력하라
3. 학생의 수 2≤n≤100,000

# 문제 풀이

1. 각 숫자들이 포인팅하는 수를 갖고 있다. 이 문제의 핵심은 사이클이 발생하지 않는 수가 몇개인지 카운팅하는 것이다.
2. 현재 정점에서 다음 정점을 타고 들어가면서 사이클 여부를 체크해야 하기 때문에 dfs로 풀어야 한다.
3. dfs에서 현재 정점의 다음 정점이 아직 방문되지 않으면 next 정점으로 dfs를 호출한다. 그렇기 때문에 dfs 함수 시작에서 방문체크를 해줄 visited 배열을 선언해야 한다. 
4. main에서 방문하지 않은 정점만 dfs 호출하기 때문에 dfs에서 이미 방문한 정점이면 4 → 5 → 6 → 4 처럼 사이클일 가능성이 있다. 그런데 2 → 1 → 3 처럼 사이클은 아닌데 1이 먼저 방문한 정점일수도 있지 않은가? 이런 경우는 사이클 탐색을 해주면 안된다. 그런데 visited 배열 한개만 있으면 판단이 어렵기 때문에 사이클 판단이 끝난 정점인지 체크해주는 finished 배열을 하나 더 선언해야 한다. dfs 함수 마지막줄에 finished[cur] = true 해주어 탐색완료했다는 표시를 해야 한다.
5. 만약 방문을 이미 했고 아직 finished된 정점이 아니라면 사이클이라는 의미이다. 왜냐하면 작은 정점부터 dfs 탐색을 하기 때문에 사이클에 속한 큰 수들은 finished가 될 수 없다.  이럴 경우 반복문으로 다음 정점들로 이동하며 cnt를 세준다.

# 정리

사이클 판단인데 너무 어려웠다. n이 십만이라서 처음에 완전 dfs로 푸니까 depth가 너무 깊어져서 stackoverflow 에러가 났다. 사이클 탐색하는 조건절을 생각해내기가 너무 힘들었다. 다른 사람 코드를 봐도 finished 배열의 의미를 이해하지 못했는데 정리하니까 이제 이해가 간다! 

```java
static boolean dfs(int cur) {
		if(cur == target) {
			return true;
		}
		if(cur != parents[cur]) {
			if(dfs(parents[cur])) {
				return true;
			}
		}
		return false;
	}
```